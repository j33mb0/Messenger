{"ast":null,"code":"import _asyncToGenerator from \"D:/My projects/csharp/TestAspAngProj/TestAspAngProj/TestAspAngProj/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nimport { MessageType } from \"./IHubProtocol\";\nimport { isArrayBuffer } from \"./Utils\";\n/** @private */\n\nexport class MessageBuffer {\n  constructor(protocol, connection, bufferSize) {\n    this._bufferSize = 100000;\n    this._messages = [];\n    this._totalMessageCount = 0;\n    this._waitForSequenceMessage = false; // Message IDs start at 1 and always increment by 1\n\n    this._nextReceivingSequenceId = 1;\n    this._latestReceivedSequenceId = 0;\n    this._bufferedByteCount = 0;\n    this._reconnectInProgress = false;\n    this._protocol = protocol;\n    this._connection = connection;\n    this._bufferSize = bufferSize;\n  }\n\n  _send(message) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const serializedMessage = _this._protocol.writeMessage(message);\n\n      let backpressurePromise = Promise.resolve(); // Only count invocation messages. Acks, pings, etc. don't need to be resent on reconnect\n\n      if (_this._isInvocationMessage(message)) {\n        _this._totalMessageCount++;\n\n        let backpressurePromiseResolver = () => {};\n\n        let backpressurePromiseRejector = () => {};\n\n        if (isArrayBuffer(serializedMessage)) {\n          _this._bufferedByteCount += serializedMessage.byteLength;\n        } else {\n          _this._bufferedByteCount += serializedMessage.length;\n        }\n\n        if (_this._bufferedByteCount >= _this._bufferSize) {\n          backpressurePromise = new Promise((resolve, reject) => {\n            backpressurePromiseResolver = resolve;\n            backpressurePromiseRejector = reject;\n          });\n        }\n\n        _this._messages.push(new BufferedItem(serializedMessage, _this._totalMessageCount, backpressurePromiseResolver, backpressurePromiseRejector));\n      }\n\n      try {\n        // If this is set it means we are reconnecting or resending\n        // We don't want to send on a disconnected connection\n        // And we don't want to send if resend is running since that would mean sending\n        // this message twice\n        if (!_this._reconnectInProgress) {\n          yield _this._connection.send(serializedMessage);\n        }\n      } catch {\n        _this._disconnected();\n      }\n\n      yield backpressurePromise;\n    })();\n  }\n\n  _ack(ackMessage) {\n    let newestAckedMessage = -1; // Find index of newest message being acked\n\n    for (let index = 0; index < this._messages.length; index++) {\n      const element = this._messages[index];\n\n      if (element._id <= ackMessage.sequenceId) {\n        newestAckedMessage = index;\n\n        if (isArrayBuffer(element._message)) {\n          this._bufferedByteCount -= element._message.byteLength;\n        } else {\n          this._bufferedByteCount -= element._message.length;\n        } // resolve items that have already been sent and acked\n\n\n        element._resolver();\n      } else if (this._bufferedByteCount < this._bufferSize) {\n        // resolve items that now fall under the buffer limit but haven't been acked\n        element._resolver();\n      } else {\n        break;\n      }\n    }\n\n    if (newestAckedMessage !== -1) {\n      // We're removing everything including the message pointed to, so add 1\n      this._messages = this._messages.slice(newestAckedMessage + 1);\n    }\n  }\n\n  _shouldProcessMessage(message) {\n    if (this._waitForSequenceMessage) {\n      if (message.type !== MessageType.Sequence) {\n        return false;\n      } else {\n        this._waitForSequenceMessage = false;\n        return true;\n      }\n    } // No special processing for acks, pings, etc.\n\n\n    if (!this._isInvocationMessage(message)) {\n      return true;\n    }\n\n    const currentId = this._nextReceivingSequenceId;\n    this._nextReceivingSequenceId++;\n\n    if (currentId <= this._latestReceivedSequenceId) {\n      if (currentId === this._latestReceivedSequenceId) {\n        // Should only hit this if we just reconnected and the server is sending\n        // Messages it has buffered, which would mean it hasn't seen an Ack for these messages\n        this._ackTimer();\n      } // Ignore, this is a duplicate message\n\n\n      return false;\n    }\n\n    this._latestReceivedSequenceId = currentId; // Only start the timer for sending an Ack message when we have a message to ack. This also conveniently solves\n    // timer throttling by not having a recursive timer, and by starting the timer via a network call (recv)\n\n    this._ackTimer();\n\n    return true;\n  }\n\n  _resetSequence(message) {\n    if (message.sequenceId > this._nextReceivingSequenceId) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this._connection.stop(new Error(\"Sequence ID greater than amount of messages we've received.\"));\n\n      return;\n    }\n\n    this._nextReceivingSequenceId = message.sequenceId;\n  }\n\n  _disconnected() {\n    this._reconnectInProgress = true;\n    this._waitForSequenceMessage = true;\n  }\n\n  _resend() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const sequenceId = _this2._messages.length !== 0 ? _this2._messages[0]._id : _this2._totalMessageCount + 1;\n      yield _this2._connection.send(_this2._protocol.writeMessage({\n        type: MessageType.Sequence,\n        sequenceId\n      })); // Get a local variable to the _messages, just in case messages are acked while resending\n      // Which would slice the _messages array (which creates a new copy)\n\n      const messages = _this2._messages;\n\n      for (const element of messages) {\n        yield _this2._connection.send(element._message);\n      }\n\n      _this2._reconnectInProgress = false;\n    })();\n  }\n\n  _dispose(error) {\n    error !== null && error !== void 0 ? error : error = new Error(\"Unable to reconnect to server.\"); // Unblock backpressure if any\n\n    for (const element of this._messages) {\n      element._rejector(error);\n    }\n  }\n\n  _isInvocationMessage(message) {\n    // There is no way to check if something implements an interface.\n    // So we individually check the messages in a switch statement.\n    // To make sure we don't miss any message types we rely on the compiler\n    // seeing the function returns a value and it will do the\n    // exhaustive check for us on the switch statement, since we don't use 'case default'\n    switch (message.type) {\n      case MessageType.Invocation:\n      case MessageType.StreamItem:\n      case MessageType.Completion:\n      case MessageType.StreamInvocation:\n      case MessageType.CancelInvocation:\n        return true;\n\n      case MessageType.Close:\n      case MessageType.Sequence:\n      case MessageType.Ping:\n      case MessageType.Ack:\n        return false;\n    }\n  }\n\n  _ackTimer() {\n    var _this3 = this;\n\n    if (this._ackTimerHandle === undefined) {\n      this._ackTimerHandle = setTimeout( /*#__PURE__*/_asyncToGenerator(function* () {\n        try {\n          if (!_this3._reconnectInProgress) {\n            yield _this3._connection.send(_this3._protocol.writeMessage({\n              type: MessageType.Ack,\n              sequenceId: _this3._latestReceivedSequenceId\n            }));\n          } // Ignore errors, that means the connection is closed and we don't care about the Ack message anymore.\n\n        } catch {}\n\n        clearTimeout(_this3._ackTimerHandle);\n        _this3._ackTimerHandle = undefined; // 1 second delay so we don't spam Ack messages if there are many messages being received at once.\n      }), 1000);\n    }\n  }\n\n}\n\nclass BufferedItem {\n  constructor(message, id, resolver, rejector) {\n    this._message = message;\n    this._id = id;\n    this._resolver = resolver;\n    this._rejector = rejector;\n  }\n\n}","map":{"version":3,"names":["MessageType","isArrayBuffer","MessageBuffer","constructor","protocol","connection","bufferSize","_bufferSize","_messages","_totalMessageCount","_waitForSequenceMessage","_nextReceivingSequenceId","_latestReceivedSequenceId","_bufferedByteCount","_reconnectInProgress","_protocol","_connection","_send","message","serializedMessage","writeMessage","backpressurePromise","Promise","resolve","_isInvocationMessage","backpressurePromiseResolver","backpressurePromiseRejector","byteLength","length","reject","push","BufferedItem","send","_disconnected","_ack","ackMessage","newestAckedMessage","index","element","_id","sequenceId","_message","_resolver","slice","_shouldProcessMessage","type","Sequence","currentId","_ackTimer","_resetSequence","stop","Error","_resend","messages","_dispose","error","_rejector","Invocation","StreamItem","Completion","StreamInvocation","CancelInvocation","Close","Ping","Ack","_ackTimerHandle","undefined","setTimeout","clearTimeout","id","resolver","rejector"],"sources":["D:/My projects/csharp/TestAspAngProj/TestAspAngProj/TestAspAngProj/ClientApp/node_modules/@microsoft/signalr/dist/esm/MessageBuffer.js"],"sourcesContent":["// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { MessageType } from \"./IHubProtocol\";\r\nimport { isArrayBuffer } from \"./Utils\";\r\n/** @private */\r\nexport class MessageBuffer {\r\n    constructor(protocol, connection, bufferSize) {\r\n        this._bufferSize = 100000;\r\n        this._messages = [];\r\n        this._totalMessageCount = 0;\r\n        this._waitForSequenceMessage = false;\r\n        // Message IDs start at 1 and always increment by 1\r\n        this._nextReceivingSequenceId = 1;\r\n        this._latestReceivedSequenceId = 0;\r\n        this._bufferedByteCount = 0;\r\n        this._reconnectInProgress = false;\r\n        this._protocol = protocol;\r\n        this._connection = connection;\r\n        this._bufferSize = bufferSize;\r\n    }\r\n    async _send(message) {\r\n        const serializedMessage = this._protocol.writeMessage(message);\r\n        let backpressurePromise = Promise.resolve();\r\n        // Only count invocation messages. Acks, pings, etc. don't need to be resent on reconnect\r\n        if (this._isInvocationMessage(message)) {\r\n            this._totalMessageCount++;\r\n            let backpressurePromiseResolver = () => { };\r\n            let backpressurePromiseRejector = () => { };\r\n            if (isArrayBuffer(serializedMessage)) {\r\n                this._bufferedByteCount += serializedMessage.byteLength;\r\n            }\r\n            else {\r\n                this._bufferedByteCount += serializedMessage.length;\r\n            }\r\n            if (this._bufferedByteCount >= this._bufferSize) {\r\n                backpressurePromise = new Promise((resolve, reject) => {\r\n                    backpressurePromiseResolver = resolve;\r\n                    backpressurePromiseRejector = reject;\r\n                });\r\n            }\r\n            this._messages.push(new BufferedItem(serializedMessage, this._totalMessageCount, backpressurePromiseResolver, backpressurePromiseRejector));\r\n        }\r\n        try {\r\n            // If this is set it means we are reconnecting or resending\r\n            // We don't want to send on a disconnected connection\r\n            // And we don't want to send if resend is running since that would mean sending\r\n            // this message twice\r\n            if (!this._reconnectInProgress) {\r\n                await this._connection.send(serializedMessage);\r\n            }\r\n        }\r\n        catch {\r\n            this._disconnected();\r\n        }\r\n        await backpressurePromise;\r\n    }\r\n    _ack(ackMessage) {\r\n        let newestAckedMessage = -1;\r\n        // Find index of newest message being acked\r\n        for (let index = 0; index < this._messages.length; index++) {\r\n            const element = this._messages[index];\r\n            if (element._id <= ackMessage.sequenceId) {\r\n                newestAckedMessage = index;\r\n                if (isArrayBuffer(element._message)) {\r\n                    this._bufferedByteCount -= element._message.byteLength;\r\n                }\r\n                else {\r\n                    this._bufferedByteCount -= element._message.length;\r\n                }\r\n                // resolve items that have already been sent and acked\r\n                element._resolver();\r\n            }\r\n            else if (this._bufferedByteCount < this._bufferSize) {\r\n                // resolve items that now fall under the buffer limit but haven't been acked\r\n                element._resolver();\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        if (newestAckedMessage !== -1) {\r\n            // We're removing everything including the message pointed to, so add 1\r\n            this._messages = this._messages.slice(newestAckedMessage + 1);\r\n        }\r\n    }\r\n    _shouldProcessMessage(message) {\r\n        if (this._waitForSequenceMessage) {\r\n            if (message.type !== MessageType.Sequence) {\r\n                return false;\r\n            }\r\n            else {\r\n                this._waitForSequenceMessage = false;\r\n                return true;\r\n            }\r\n        }\r\n        // No special processing for acks, pings, etc.\r\n        if (!this._isInvocationMessage(message)) {\r\n            return true;\r\n        }\r\n        const currentId = this._nextReceivingSequenceId;\r\n        this._nextReceivingSequenceId++;\r\n        if (currentId <= this._latestReceivedSequenceId) {\r\n            if (currentId === this._latestReceivedSequenceId) {\r\n                // Should only hit this if we just reconnected and the server is sending\r\n                // Messages it has buffered, which would mean it hasn't seen an Ack for these messages\r\n                this._ackTimer();\r\n            }\r\n            // Ignore, this is a duplicate message\r\n            return false;\r\n        }\r\n        this._latestReceivedSequenceId = currentId;\r\n        // Only start the timer for sending an Ack message when we have a message to ack. This also conveniently solves\r\n        // timer throttling by not having a recursive timer, and by starting the timer via a network call (recv)\r\n        this._ackTimer();\r\n        return true;\r\n    }\r\n    _resetSequence(message) {\r\n        if (message.sequenceId > this._nextReceivingSequenceId) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            this._connection.stop(new Error(\"Sequence ID greater than amount of messages we've received.\"));\r\n            return;\r\n        }\r\n        this._nextReceivingSequenceId = message.sequenceId;\r\n    }\r\n    _disconnected() {\r\n        this._reconnectInProgress = true;\r\n        this._waitForSequenceMessage = true;\r\n    }\r\n    async _resend() {\r\n        const sequenceId = this._messages.length !== 0\r\n            ? this._messages[0]._id\r\n            : this._totalMessageCount + 1;\r\n        await this._connection.send(this._protocol.writeMessage({ type: MessageType.Sequence, sequenceId }));\r\n        // Get a local variable to the _messages, just in case messages are acked while resending\r\n        // Which would slice the _messages array (which creates a new copy)\r\n        const messages = this._messages;\r\n        for (const element of messages) {\r\n            await this._connection.send(element._message);\r\n        }\r\n        this._reconnectInProgress = false;\r\n    }\r\n    _dispose(error) {\r\n        error !== null && error !== void 0 ? error : (error = new Error(\"Unable to reconnect to server.\"));\r\n        // Unblock backpressure if any\r\n        for (const element of this._messages) {\r\n            element._rejector(error);\r\n        }\r\n    }\r\n    _isInvocationMessage(message) {\r\n        // There is no way to check if something implements an interface.\r\n        // So we individually check the messages in a switch statement.\r\n        // To make sure we don't miss any message types we rely on the compiler\r\n        // seeing the function returns a value and it will do the\r\n        // exhaustive check for us on the switch statement, since we don't use 'case default'\r\n        switch (message.type) {\r\n            case MessageType.Invocation:\r\n            case MessageType.StreamItem:\r\n            case MessageType.Completion:\r\n            case MessageType.StreamInvocation:\r\n            case MessageType.CancelInvocation:\r\n                return true;\r\n            case MessageType.Close:\r\n            case MessageType.Sequence:\r\n            case MessageType.Ping:\r\n            case MessageType.Ack:\r\n                return false;\r\n        }\r\n    }\r\n    _ackTimer() {\r\n        if (this._ackTimerHandle === undefined) {\r\n            this._ackTimerHandle = setTimeout(async () => {\r\n                try {\r\n                    if (!this._reconnectInProgress) {\r\n                        await this._connection.send(this._protocol.writeMessage({ type: MessageType.Ack, sequenceId: this._latestReceivedSequenceId }));\r\n                    }\r\n                    // Ignore errors, that means the connection is closed and we don't care about the Ack message anymore.\r\n                }\r\n                catch { }\r\n                clearTimeout(this._ackTimerHandle);\r\n                this._ackTimerHandle = undefined;\r\n                // 1 second delay so we don't spam Ack messages if there are many messages being received at once.\r\n            }, 1000);\r\n        }\r\n    }\r\n}\r\nclass BufferedItem {\r\n    constructor(message, id, resolver, rejector) {\r\n        this._message = message;\r\n        this._id = id;\r\n        this._resolver = resolver;\r\n        this._rejector = rejector;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}