{"ast":null,"code":"import _asyncToGenerator from \"D:/My projects/csharp/TestAspAngProj/TestAspAngProj/TestAspAngProj/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nimport { LogLevel } from \"./ILogger\";\nimport { TransferFormat } from \"./ITransport\";\nimport { Arg, getDataDetail, getUserAgentHeader, Platform, sendMessage } from \"./Utils\";\n/** @private */\n\nexport class ServerSentEventsTransport {\n  constructor(httpClient, accessToken, logger, options) {\n    this._httpClient = httpClient;\n    this._accessToken = accessToken;\n    this._logger = logger;\n    this._options = options;\n    this.onreceive = null;\n    this.onclose = null;\n  }\n\n  connect(url, transferFormat) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      Arg.isRequired(url, \"url\");\n      Arg.isRequired(transferFormat, \"transferFormat\");\n      Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\n\n      _this._logger.log(LogLevel.Trace, \"(SSE transport) Connecting.\"); // set url before accessTokenFactory because this._url is only for send and we set the auth header instead of the query string for send\n\n\n      _this._url = url;\n\n      if (_this._accessToken) {\n        url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(_this._accessToken)}`;\n      }\n\n      return new Promise((resolve, reject) => {\n        let opened = false;\n\n        if (transferFormat !== TransferFormat.Text) {\n          reject(new Error(\"The Server-Sent Events transport only supports the 'Text' transfer format\"));\n          return;\n        }\n\n        let eventSource;\n\n        if (Platform.isBrowser || Platform.isWebWorker) {\n          eventSource = new _this._options.EventSource(url, {\n            withCredentials: _this._options.withCredentials\n          });\n        } else {\n          // Non-browser passes cookies via the dictionary\n          const cookies = _this._httpClient.getCookieString(url);\n\n          const headers = {};\n          headers.Cookie = cookies;\n          const [name, value] = getUserAgentHeader();\n          headers[name] = value;\n          eventSource = new _this._options.EventSource(url, {\n            withCredentials: _this._options.withCredentials,\n            headers: { ...headers,\n              ..._this._options.headers\n            }\n          });\n        }\n\n        try {\n          eventSource.onmessage = e => {\n            if (_this.onreceive) {\n              try {\n                _this._logger.log(LogLevel.Trace, `(SSE transport) data received. ${getDataDetail(e.data, _this._options.logMessageContent)}.`);\n\n                _this.onreceive(e.data);\n              } catch (error) {\n                _this._close(error);\n\n                return;\n              }\n            }\n          }; // @ts-ignore: not using event on purpose\n\n\n          eventSource.onerror = e => {\n            // EventSource doesn't give any useful information about server side closes.\n            if (opened) {\n              _this._close();\n            } else {\n              reject(new Error(\"EventSource failed to connect. The connection could not be found on the server,\" + \" either the connection ID is not present on the server, or a proxy is refusing/buffering the connection.\" + \" If you have multiple servers check that sticky sessions are enabled.\"));\n            }\n          };\n\n          eventSource.onopen = () => {\n            _this._logger.log(LogLevel.Information, `SSE connected to ${_this._url}`);\n\n            _this._eventSource = eventSource;\n            opened = true;\n            resolve();\n          };\n        } catch (e) {\n          reject(e);\n          return;\n        }\n      });\n    })();\n  }\n\n  send(data) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this2._eventSource) {\n        return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\n      }\n\n      return sendMessage(_this2._logger, \"SSE\", _this2._httpClient, _this2._url, data, _this2._options);\n    })();\n  }\n\n  stop() {\n    this._close();\n\n    return Promise.resolve();\n  }\n\n  _close(e) {\n    if (this._eventSource) {\n      this._eventSource.close();\n\n      this._eventSource = undefined;\n\n      if (this.onclose) {\n        this.onclose(e);\n      }\n    }\n  }\n\n}","map":{"version":3,"names":["LogLevel","TransferFormat","Arg","getDataDetail","getUserAgentHeader","Platform","sendMessage","ServerSentEventsTransport","constructor","httpClient","accessToken","logger","options","_httpClient","_accessToken","_logger","_options","onreceive","onclose","connect","url","transferFormat","isRequired","isIn","log","Trace","_url","indexOf","encodeURIComponent","Promise","resolve","reject","opened","Text","Error","eventSource","isBrowser","isWebWorker","EventSource","withCredentials","cookies","getCookieString","headers","Cookie","name","value","onmessage","e","data","logMessageContent","error","_close","onerror","onopen","Information","_eventSource","send","stop","close","undefined"],"sources":["D:/My projects/csharp/TestAspAngProj/TestAspAngProj/TestAspAngProj/ClientApp/node_modules/@microsoft/signalr/dist/esm/ServerSentEventsTransport.js"],"sourcesContent":["// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { TransferFormat } from \"./ITransport\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, Platform, sendMessage } from \"./Utils\";\r\n/** @private */\r\nexport class ServerSentEventsTransport {\r\n    constructor(httpClient, accessToken, logger, options) {\r\n        this._httpClient = httpClient;\r\n        this._accessToken = accessToken;\r\n        this._logger = logger;\r\n        this._options = options;\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n    async connect(url, transferFormat) {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n        this._logger.log(LogLevel.Trace, \"(SSE transport) Connecting.\");\r\n        // set url before accessTokenFactory because this._url is only for send and we set the auth header instead of the query string for send\r\n        this._url = url;\r\n        if (this._accessToken) {\r\n            url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(this._accessToken)}`;\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            let opened = false;\r\n            if (transferFormat !== TransferFormat.Text) {\r\n                reject(new Error(\"The Server-Sent Events transport only supports the 'Text' transfer format\"));\r\n                return;\r\n            }\r\n            let eventSource;\r\n            if (Platform.isBrowser || Platform.isWebWorker) {\r\n                eventSource = new this._options.EventSource(url, { withCredentials: this._options.withCredentials });\r\n            }\r\n            else {\r\n                // Non-browser passes cookies via the dictionary\r\n                const cookies = this._httpClient.getCookieString(url);\r\n                const headers = {};\r\n                headers.Cookie = cookies;\r\n                const [name, value] = getUserAgentHeader();\r\n                headers[name] = value;\r\n                eventSource = new this._options.EventSource(url, { withCredentials: this._options.withCredentials, headers: { ...headers, ...this._options.headers } });\r\n            }\r\n            try {\r\n                eventSource.onmessage = (e) => {\r\n                    if (this.onreceive) {\r\n                        try {\r\n                            this._logger.log(LogLevel.Trace, `(SSE transport) data received. ${getDataDetail(e.data, this._options.logMessageContent)}.`);\r\n                            this.onreceive(e.data);\r\n                        }\r\n                        catch (error) {\r\n                            this._close(error);\r\n                            return;\r\n                        }\r\n                    }\r\n                };\r\n                // @ts-ignore: not using event on purpose\r\n                eventSource.onerror = (e) => {\r\n                    // EventSource doesn't give any useful information about server side closes.\r\n                    if (opened) {\r\n                        this._close();\r\n                    }\r\n                    else {\r\n                        reject(new Error(\"EventSource failed to connect. The connection could not be found on the server,\"\r\n                            + \" either the connection ID is not present on the server, or a proxy is refusing/buffering the connection.\"\r\n                            + \" If you have multiple servers check that sticky sessions are enabled.\"));\r\n                    }\r\n                };\r\n                eventSource.onopen = () => {\r\n                    this._logger.log(LogLevel.Information, `SSE connected to ${this._url}`);\r\n                    this._eventSource = eventSource;\r\n                    opened = true;\r\n                    resolve();\r\n                };\r\n            }\r\n            catch (e) {\r\n                reject(e);\r\n                return;\r\n            }\r\n        });\r\n    }\r\n    async send(data) {\r\n        if (!this._eventSource) {\r\n            return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\r\n        }\r\n        return sendMessage(this._logger, \"SSE\", this._httpClient, this._url, data, this._options);\r\n    }\r\n    stop() {\r\n        this._close();\r\n        return Promise.resolve();\r\n    }\r\n    _close(e) {\r\n        if (this._eventSource) {\r\n            this._eventSource.close();\r\n            this._eventSource = undefined;\r\n            if (this.onclose) {\r\n                this.onclose(e);\r\n            }\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}